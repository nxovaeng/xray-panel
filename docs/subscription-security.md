# 订阅系统安全说明

## 订阅链接机制

### 1. 动态生成 ✅

**是的，订阅内容是动态生成的！**

每次用户访问订阅链接时：
1. 系统查询该用户的信息
2. 查询所有启用的入站
3. 实时生成所有节点的连接链接
4. 返回最新的订阅内容

```
用户访问订阅链接
    ↓
验证 SubPath
    ↓
检查用户状态
    ↓
查询启用的入站
    ↓
动态生成连接链接
    ↓
返回订阅内容
```

**优势**：
- ✅ 始终返回最新的节点列表
- ✅ 添加/删除节点立即生效
- ✅ 用户状态实时检查
- ✅ 流量和到期时间实时验证

### 2. 订阅链接地址

**每个用户的订阅链接都是唯一的！** 🔐

#### 链接格式

```
https://your-domain.com/sub/{SubPath}
https://your-domain.com/sub/{SubPath}/{format}
```

**示例**：
```
用户 A: https://panel.example.com/sub/a1b2c3d4
用户 B: https://panel.example.com/sub/e5f6g7h8
用户 C: https://panel.example.com/sub/i9j0k1l2
```

#### SubPath 生成

**自动生成** (`internal/models/user.go`):
```go
func (u *User) BeforeCreate(tx *gorm.DB) error {
    if u.SubPath == "" {
        // 使用 UUID 的前 8 位作为订阅路径
        u.SubPath = uuid.New().String()[:8]
    }
    return nil
}
```

**特点**：
- 8 字符长度
- 随机生成（UUID 前缀）
- 唯一索引（数据库保证唯一性）
- 难以猜测

**示例 SubPath**：
```
a1b2c3d4
e5f6g7h8
i9j0k1l2
m3n4o5p6
```

### 3. 安全保护机制

#### 3.1 路径唯一性 🔒

**数据库约束**：
```go
SubPath string `gorm:"uniqueIndex"`
```

- 每个用户有唯一的 SubPath
- 数据库级别保证不重复
- 无法通过 SubPath 推测其他用户

#### 3.2 用户状态验证 ✅

**访问订阅时检查** (`internal/api/subscription.go`):
```go
// 1. 查找用户
var user models.User
if err := db.Where("sub_path = ?", path).First(&user).Error; err != nil {
    return "Subscription not found"  // 404
}

// 2. 检查用户状态
if !user.IsActive() {
    return "Subscription expired or disabled"  // 403
}
```

**验证项目**：
- ✅ SubPath 是否存在
- ✅ 用户是否启用
- ✅ 是否已过期
- ✅ 流量是否超限

#### 3.3 IsActive() 检查

**多重验证** (`internal/models/user.go`):
```go
func (u *User) IsActive() bool {
    // 1. 检查启用状态
    if !u.Enabled {
        return false
    }
    
    // 2. 检查到期时间
    if !u.ExpiryDate.IsZero() && time.Now().After(u.ExpiryDate) {
        return false
    }
    
    // 3. 检查流量限制
    if u.TrafficLimit > 0 && u.TrafficUsed >= u.TrafficLimit {
        return false
    }
    
    return true
}
```

#### 3.4 无需认证 🌐

**公开访问，但受保护**：
- 不需要登录
- 不需要 Token
- 通过 SubPath 识别用户
- SubPath 本身就是"密钥"

**为什么这样设计？**
- ✅ 客户端无需存储密码
- ✅ 订阅链接可以直接导入
- ✅ 符合订阅协议标准
- ✅ SubPath 足够随机，难以猜测

### 4. 支持的格式

#### 4.1 Base64 格式（默认）

```
GET /sub/{SubPath}
GET /sub/{SubPath}/base64
```

**返回**：
```
dmxlc3M6Ly8xMjM0NTY3OC0xMjM0LTEyMzQtMTIzNC0xMjM0NTY3ODlhYmNAZXhhbXBsZS5jb206NDQzP3R5cGU9d3Mmc2VjdXJpdHk9dGxzJnNuaT1leGFtcGxlLmNvbSZwYXRoPS9wYXRoI05vZGUxCnZsZXNzOi8vLi4u
```

**用途**：
- v2rayN
- v2rayNG
- Shadowrocket
- 大多数客户端

#### 4.2 Plain 格式

```
GET /sub/{SubPath}/plain
GET /sub/{SubPath}/txt
```

**返回**：
```
vless://12345678-1234-1234-1234-123456789abc@example.com:443?type=ws&security=tls&sni=example.com&path=/path#Node1
vless://12345678-1234-1234-1234-123456789abc@example.com:443?type=grpc&security=tls&sni=example.com&serviceName=grpc#Node2
```

**用途**：
- 手动导入
- 调试
- 查看链接内容

#### 4.3 JSON 格式

```
GET /sub/{SubPath}/json
```

**返回**：
```json
{
  "success": true,
  "data": {
    "links": [
      "vless://...",
      "vless://..."
    ],
    "count": 2,
    "user": {
      "name": "张三",
      "email": "zhangsan@example.com",
      "uuid": "12345678-1234-1234-1234-123456789abc",
      "traffic_used": 1073741824,
      "traffic_limit": 107374182400,
      "remaining_days": 30,
      "is_active": true
    }
  }
}
```

**用途**：
- API 集成
- 自定义客户端
- 监控和统计

#### 4.4 Clash 格式

```
GET /sub/{SubPath}/clash
```

**返回**：
```yaml
# Clash Configuration
# User: 张三
# Generated by Xray Panel

proxies:
  - name: "Node1-VLESS-WS"
    type: vless
    server: example.com
    port: 443
    uuid: 12345678-1234-1234-1234-123456789abc
    cipher: none
    network: ws
    tls: true
    servername: example.com
    ws-opts:
      path: /path
```

**用途**：
- Clash
- Clash for Windows
- Clash for Android

### 5. 订阅信息头

**自动添加** (`internal/api/subscription.go`):
```go
// 订阅信息（客户端可读取）
c.Header("Subscription-Userinfo", 
    "upload=0; download=1073741824; total=107374182400; expire=1735689600")

// 更新间隔（建议客户端每 24 小时更新）
c.Header("Profile-Update-Interval", "24")

// 配置文件标题
c.Header("Profile-Title", "Xray - 张三")
```

**客户端可以读取这些信息**：
- 已上传流量
- 已下载流量
- 总流量限制
- 到期时间戳
- 更新间隔
- 配置标题

### 6. 安全最佳实践

#### 6.1 保护 SubPath 🔐

**用户应该**：
- ✅ 不要公开分享订阅链接
- ✅ 不要在公共场所展示
- ✅ 定期检查订阅使用情况

**管理员应该**：
- ✅ 监控异常流量
- ✅ 设置合理的流量限制
- ✅ 定期审查用户状态

#### 6.2 流量监控 📊

**建议实施**：
```
1. 设置流量告警
   - 用户流量达到 80% 时提醒
   - 用户流量超限时禁用

2. 异常检测
   - 短时间内大量流量
   - 异常访问模式
   - 多地同时登录

3. 定期审计
   - 查看流量使用情况
   - 检查过期用户
   - 清理无效订阅
```

#### 6.3 访问日志 📝

**建议记录**：
```
- 订阅访问时间
- 访问 IP 地址
- 访问格式
- 用户状态
```

**用途**：
- 安全审计
- 异常检测
- 问题排查

#### 6.4 HTTPS 必需 🔒

**强制使用 HTTPS**：
```
http://panel.example.com/sub/xxx  ❌ 不安全
https://panel.example.com/sub/xxx ✅ 安全
```

**原因**：
- 防止 SubPath 泄露
- 防止中间人攻击
- 保护订阅内容

### 7. 攻击防护

#### 7.1 暴力破解防护

**SubPath 特点**：
- 8 字符长度
- 16 进制字符（0-9, a-f）
- 可能性：16^8 = 4,294,967,296 种

**破解难度**：
```
假设每秒尝试 1000 次
需要时间：4,294,967,296 / 1000 / 60 / 60 / 24 ≈ 49,710 天
```

**额外保护**：
- 可以添加访问频率限制
- 可以记录失败尝试
- 可以封禁异常 IP

#### 7.2 DDoS 防护

**建议措施**：
```
1. 使用 CDN
   - Cloudflare
   - 阿里云 CDN
   - 腾讯云 CDN

2. 限流
   - Nginx limit_req
   - 应用层限流

3. 缓存
   - 短时间缓存订阅内容
   - 减轻数据库压力
```

#### 7.3 订阅盗用防护

**检测方法**：
```
1. IP 地理位置检测
   - 记录常用 IP
   - 检测异常地区访问

2. 访问频率检测
   - 正常：每天 1-2 次
   - 异常：每分钟多次

3. 设备指纹
   - User-Agent 分析
   - 客户端类型识别
```

### 8. 订阅更新机制

#### 8.1 客户端更新

**自动更新**：
```
客户端读取 Profile-Update-Interval: 24
    ↓
每 24 小时自动请求订阅链接
    ↓
获取最新节点列表
    ↓
更新本地配置
```

**手动更新**：
```
用户点击"更新订阅"
    ↓
立即请求订阅链接
    ↓
获取最新配置
```

#### 8.2 服务端更新

**实时生效**：
```
管理员添加新节点
    ↓
保存到数据库
    ↓
用户下次更新订阅时
    ↓
自动包含新节点
```

**无需重启**：
- 添加节点：立即生效
- 删除节点：立即生效
- 修改节点：立即生效
- 禁用用户：立即生效

### 9. 常见问题

#### Q1: SubPath 会变化吗？

**A**: 不会！
- SubPath 在创建用户时生成
- 永久不变（除非手动修改）
- 用户可以长期使用同一个订阅链接

#### Q2: 如何重置订阅链接？

**A**: 修改用户的 SubPath
```sql
UPDATE users SET sub_path = 'new-path' WHERE id = 'user-id';
```

**用途**：
- 订阅链接泄露时
- 安全事件后
- 用户请求更换

#### Q3: 订阅链接可以分享吗？

**A**: 不建议！
- 订阅链接是个人专用的
- 分享会导致流量被盗用
- 可能导致账号被封

#### Q4: 如何查看谁在使用我的订阅？

**A**: 查看访问日志
- 记录订阅访问时间
- 记录访问 IP
- 分析异常访问

#### Q5: 订阅内容会缓存吗？

**A**: 不会！
- 每次访问都动态生成
- 始终返回最新内容
- 可以考虑添加短时间缓存（如 5 分钟）

### 10. 技术实现

#### 10.1 路由注册

```go
// 订阅路由（公开访问）
router.GET("/sub/:path", handleSubscription)
router.GET("/sub/:path/:format", handleSubscription)
```

#### 10.2 处理流程

```go
func handleSubscription(c *gin.Context) {
    // 1. 获取参数
    path := c.Param("path")
    format := c.Param("format")
    
    // 2. 查找用户
    var user User
    db.Where("sub_path = ?", path).First(&user)
    
    // 3. 验证状态
    if !user.IsActive() {
        return "Subscription expired"
    }
    
    // 4. 查询入站
    var inbounds []Inbound
    db.Where("enabled = ?", true).Find(&inbounds)
    
    // 5. 生成链接
    for _, inbound := range inbounds {
        link := generateVLESSLink(user, inbound)
        links = append(links, link)
    }
    
    // 6. 返回内容
    return formatSubscription(links, format)
}
```

#### 10.3 链接生成

```go
func generateVLESSLink(user User, inbound Inbound) string {
    return fmt.Sprintf(
        "vless://%s@%s:%d?type=%s&security=tls&sni=%s&path=%s#%s",
        user.UUID,
        inbound.Domain.Domain,
        443,
        inbound.Transport,
        inbound.Domain.Domain,
        inbound.Path,
        inbound.Remark,
    )
}
```

## 总结

### 订阅系统特点

✅ **动态生成** - 每次访问实时生成最新内容  
✅ **唯一链接** - 每个用户有独立的 SubPath  
✅ **状态验证** - 实时检查用户状态和流量  
✅ **多格式支持** - Base64, Plain, JSON, Clash  
✅ **安全保护** - SubPath 随机生成，难以猜测  
✅ **实时更新** - 节点变化立即生效  
✅ **无需认证** - SubPath 本身就是密钥  

### 安全建议

🔒 **用户端**：
- 不要分享订阅链接
- 使用 HTTPS 访问
- 定期更新订阅

🔒 **管理端**：
- 监控流量使用
- 设置合理限制
- 记录访问日志
- 使用 CDN 保护

### 最佳实践

1. **启用 HTTPS** - 必需
2. **设置流量限制** - 防止滥用
3. **定期审计** - 检查异常
4. **监控日志** - 发现问题
5. **使用 CDN** - 提高性能和安全性
